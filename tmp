
    int aabb_check(Scene& scene, float dt) {
        auto objs = scene.registry.view<TransformComp,PhysicsBodyComp>();
        for (auto [e, t, ph] : objs.each()) {
            Vector3 tp = t.position;
            if (!ph.is_solid)
            {
                t.position += ph.move_delta;
                if (ph.intersects_callback || ph.lua_callback)
                {
                    for (auto [o, ot, oph] : objs.each()) {
                        if (e != o && aabb_3d_intersects(t.position, t.size, ot.position, ot.size)) {
                            if(handle_callback(scene,ph,e,o))
                                return 1;
                        }
                    }
                }
                continue;
            }
            bool allowed_x = true, allowed_y = true, allowed_z = true;

            for (auto [o, ot, oph] : objs.each()) {
                Vector3 tmp = t.position + ph.move_delta;
                if (e == o || 
                    !oph.is_solid || 
                    dist_vec3(tmp, ot.position) > std::max({t.size.x,t.size.y,t.size.z}) + std::max({ot.size.x,ot.size.y,ot.size.z}) ||
                    !aabb_3d_intersects(t.position + ph.move_delta, t.size, ot.position, ot.size)) continue;

                tmp = Vector3{tp.x + ph.move_delta.x, tp.y, tp.z};
                HANDLE_AABB(tmp, t, ot, ph, oph, x);

                tmp = Vector3{tp.x, tp.y + ph.move_delta.y, tp.z};
                HANDLE_AABB(tmp, t, ot, ph, oph, y);

                tmp = Vector3{tp.x, tp.y, tp.z + ph.move_delta.z};
                HANDLE_AABB(tmp, t, ot, ph, oph, z);

                if(ph.intersects_callback || ph.lua_callback) {
                    if(handle_callback(scene,ph,e,o))
                        return 1;
                }
                    

            }
            t.position.x += (allowed_x) ? ph.move_delta.x : 0.0f;
            t.position.y += (allowed_y) ? ph.move_delta.y : 0.0f;
            t.position.z += (allowed_z) ? ph.move_delta.z : 0.0f;
        }

        return 0;
    }
